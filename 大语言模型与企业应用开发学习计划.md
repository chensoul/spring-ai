# 大语言模型与企业应用开发学习计划

## 📋 学习计划概述

### 🎯 学习目标
- 掌握大语言模型（LLM）的基础理论和工作原理
- 学会使用Spring AI框架进行企业级AI应用开发
- 深入理解并实践RAG（检索增强生成）技术
- 掌握MCP（Model Context Protocol）协议和应用
- 掌握模型微调、Agent开发等前沿技术
- 熟练使用多框架生态（LangChain4j、LlamaIndex、Dify）
- 能够独立开发和部署企业级AI应用

### 🎯 **目标定位**
- **适用人群**：Java高级应用开发工程师（3-8年经验）
- **技术背景**：熟悉Spring生态、微服务架构、企业级应用开发
- **学习目标**：快速转型AI应用开发，具备企业面试竞争力

### ⏱️ 总体时间安排
- **总时长**：26-36周（6.5-9个月）
- **每周学习时间**：12-15小时（更现实的时间安排）
- **实践项目时间**：占总学习时间的75%
- **评估检验时间**：每2周进行技能检验

### 📈 **学习路径选择**
- **🏃‍♂️ 快速路径**：26周（适合时间紧张的学习者）
  - 核心项目：12个
  - 重点技术：Spring AI + LangChain4j + RAG + Agent基础
  - 目标：快速具备企业AI开发能力
  - 适合：有3-5年Java经验，希望快速转型

- **🎓 深度路径**：36周（适合希望全面掌握的学习者）
  - 完整项目：18个
  - 全技术栈：包含MCP协议、模型微调、多框架集成等高级特性
  - 目标：成为AI应用开发专家
  - 适合：有5-8年Java经验，追求技术深度

- **🔧 定制路径**：根据个人基础和目标灵活调整
  - 可跳过已掌握的技术
  - 可重点加强感兴趣的方向
  - 可根据求职需求调整重点

### 🎯 **核心技术栈覆盖**
- **Java AI框架**：Spring AI + LangChain4j（双框架掌握）
- **模型部署**：OpenAI API + Ollama本地模型 + Azure OpenAI
- **RAG技术栈**：PostgreSQL+pgvector + Elasticsearch + Redis缓存
- **Agent开发**：工具调用 + 推理链 + 多Agent协作 + MCP协议
- **企业级特性**：Spring Security + 监控指标 + Docker部署 + 测试框架
- **开发工具**：Testcontainers + Docker Compose + Micrometer + ELK Stack

---

## 🚀 第一阶段：LLM基础理论 + Spring AI入门（4-5周）

> **⏱️ 时间分配**：快速路径4周，深度路径5周
> **🎯 核心目标**：快速建立AI应用开发基础，利用Java背景优势
> **🔧 新增内容**：Ollama本地模型部署，降低学习成本

### 📚 学习目标
- 理解LLM的基本理论和工作原理
- 掌握Spring AI框架的核心概念和基础API
- 完成第一个AI应用项目
- 建立AI应用开发的基础认知

### 📅 详细安排

#### 第1-2周：LLM基础理论 + 模型选型
**学习内容：**
- Transformer架构原理（注意力机制、位置编码）
- 预训练和微调概念
- 提示词工程基础
- LLM应用开发范式
- **主流LLM模型特点和使用场景对比**
- **企业级模型选型策略**

**学习资源：**
- 📖 《Attention Is All You Need》论文精读
- 🎥 [3Blue1Brown Transformer视频](https://www.youtube.com/watch?v=4Bdc55j80l8)
- 📝 [OpenAI提示词工程指南](https://platform.openai.com/docs/guides/prompt-engineering)
- 🔗 [Spring AI官方文档](https://docs.spring.io/spring-ai/reference/)
- 📊 [LLM模型性能对比报告](https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard)
- 📝 [企业级AI模型选型指南](https://www.anthropic.com/claude)

**🤖 主流LLM模型特点和使用场景（面试重点）：**

| 模型系列 | 代表模型 | 参数规模 | 特点 | 适用场景 | 成本 |
|---------|---------|---------|------|---------|------|
| **GPT系列** | GPT-4, GPT-3.5 | 175B-1.7T | 通用性强、推理能力优秀 | 企业级应用、复杂推理 | 高 |
| **Claude系列** | Claude-3.5 Sonnet | 未公开 | 安全性高、长文本处理 | 文档分析、代码生成 | 中高 |
| **Llama系列** | Llama 3.1 | 8B-405B | 开源、可本地部署 | 成本敏感、数据隐私 | 低 |
| **Gemini系列** | Gemini Pro | 未公开 | 多模态、Google生态 | 搜索增强、多媒体 | 中 |
| **文心一言** | ERNIE 4.0 | 未公开 | 中文优化、百度生态 | 中文应用、本土化 | 中 |
| **通义千问** | Qwen2.5 | 7B-72B | 中文优化、阿里生态 | 电商、中文NLP | 中 |
| **智谱GLM** | GLM-4 | 9B | 中英双语、代码生成 | 编程助手、教育 | 中 |

**🎯 模型选型决策框架（面试必问）：**
- **成本预算**：开源模型 < 国产模型 < 国外商业模型
- **数据隐私**：本地部署 > 私有云 > 公有云API
- **性能要求**：GPT-4 > Claude-3.5 > 国产模型 > 开源模型
- **中文能力**：国产模型 > GPT-4 > Claude > Llama
- **部署复杂度**：API调用 < 容器化 < 本地部署

**实践项目：**
```java
// 项目1：智能模型选型系统
@Service
public class ModelSelectionService {
    
    /**
     * 企业级模型选型决策（面试重点）
     */
    public ModelRecommendation selectModel(BusinessRequirement requirement) {
        // 1. 成本预算评估
        if (requirement.getBudget() < 1000) {
            return recommendOpenSourceModel(requirement);
        }
        
        // 2. 数据隐私要求
        if (requirement.isDataPrivacyRequired()) {
            return recommendLocalModel(requirement);
        }
        
        // 3. 性能要求评估
        if (requirement.isHighPerformanceRequired()) {
            return recommendCloudModel(requirement);
        }
        
        // 4. 语言和地域要求
        if (requirement.getLanguage().equals("zh-CN")) {
            return recommendChineseModel(requirement);
        }
        
        return recommendGeneralModel(requirement);
    }
    
    private ModelRecommendation recommendOpenSourceModel(BusinessRequirement req) {
        return ModelRecommendation.builder()
            .modelName("Llama 3.1 8B")
            .deployment("本地部署")
            .estimatedCost("$0/月（硬件成本除外）")
            .pros(List.of("完全免费", "数据隐私", "可定制"))
            .cons(List.of("需要GPU资源", "维护成本", "性能相对较低"))
            .useCase("中小企业、原型开发、成本敏感场景")
            .build();
    }
    
    private ModelRecommendation recommendCloudModel(BusinessRequirement req) {
        return ModelRecommendation.builder()
            .modelName("GPT-4")
            .deployment("API调用")
            .estimatedCost("$20-100/月")
            .pros(List.of("性能最佳", "无需维护", "持续更新"))
            .cons(List.of("成本较高", "数据传输", "依赖网络"))
            .useCase("企业级应用、高质量要求、复杂推理")
            .build();
    }
    
    private ModelRecommendation recommendChineseModel(BusinessRequirement req) {
        return ModelRecommendation.builder()
            .modelName("通义千问 Qwen2.5")
            .deployment("API调用")
            .estimatedCost("$10-50/月")
            .pros(List.of("中文优化", "本土化服务", "合规性"))
            .cons(List.of("国际化有限", "生态相对较小"))
            .useCase("中文应用、本土企业、合规要求")
            .build();
    }
}

// 基础聊天机器人
@Service
public class BasicChatService {
    private final ChatClient chatClient;
    
    public String chat(String message) {
        return chatClient.prompt(message)
            .call()
            .content();
    }
    
    // 添加系统提示词
    public String chatWithSystem(String message, String systemPrompt) {
        return chatClient.prompt()
            .system(systemPrompt)
            .user(message)
            .call()
            .content();
    }
}

/**
 * 模型性能对比测试（面试重点）
 */
@Component
public class ModelBenchmark {
    
    public ModelComparisonResult compareModels(String testPrompt) {
        /*
        性能维度对比：
        
        1. 推理能力：GPT-4 > Claude-3.5 > Llama 3.1 > 国产模型
        2. 代码生成：Claude-3.5 > GPT-4 > Llama 3.1 > 通义千问
        3. 中文理解：文心一言 > 通义千问 > GPT-4 > Claude-3.5
        4. 成本效益：Llama 3.1 > 国产模型 > GPT-3.5 > GPT-4
        5. 部署灵活性：Llama 3.1 > 国产模型 > 云端模型
        
        选型建议：
        - 初创公司：Llama 3.1 + Ollama本地部署
        - 中型企业：GPT-3.5 + 国产模型混合
        - 大型企业：GPT-4 + 私有化部署
        - 中文场景：通义千问/文心一言 + GPT-4补充
        */
        
        return ModelComparisonResult.builder()
            .testPrompt(testPrompt)
            .recommendations(getRecommendations())
            .build();
    }
}
```

**学习成果：**
- [ ] 能够解释Transformer架构的核心组件
- [ ] 理解注意力机制的工作原理
- [ ] 掌握基础提示词工程技巧
- [ ] **掌握主流LLM模型特点和选型策略**
- [ ] **能够进行企业级模型成本效益分析**
- [ ] **理解不同模型的适用场景和部署方式**
- [ ] 完成智能模型选型系统项目

#### 第3-4周：Spring AI框架入门
**学习内容：**
- Spring AI核心概念和架构
- ChatClient API使用
- 配置管理和依赖注入
- 错误处理和重试机制

**学习资源：**
- 📚 [Spring AI 1.0官方文档](https://docs.spring.io/spring-ai/reference/)
- 🎥 Spring官方视频教程
- 📝 [Spring AI最佳实践](https://github.com/spring-projects/spring-ai)

**实践项目：**
```java
// 项目2：智能问答系统
@Service
public class QAService {
    private final ChatClient chatClient;
    
    public String answerQuestion(String question, String context) {
        return chatClient.prompt()
            .system("你是一个专业的问答助手，请基于提供的上下文回答问题。")
            .user("""
                上下文：{context}
                
                问题：{question}
                """, Map.of("context", context, "question", question))
            .call()
            .content();
    }
    
    // 结构化输出
    public record Answer(String answer, String confidence, List<String> sources) {}
    
    public Answer getStructuredAnswer(String question) {
        return chatClient.prompt()
            .system("返回JSON格式的回答，包含答案、置信度和来源")
            .user(question)
            .call()
            .entity(Answer.class);
    }
}
```

**学习成果：**
- [ ] 熟练使用Spring AI基础API
- [ ] 掌握配置管理和依赖注入
- [ ] 实现结构化输出功能
- [ ] 完成智能问答系统项目

#### 第5周：Ollama本地模型部署
**学习内容：**
- Ollama安装和配置
- 本地模型下载和管理
- Spring AI与Ollama集成
- 成本控制和开发环境优化

**学习资源：**
- 📖 [Ollama官方文档](https://ollama.ai/docs)
- 🎥 Ollama安装配置教程
- 📝 [Spring AI Ollama集成指南](https://docs.spring.io/spring-ai/reference/api/chat/ollama-chat.html)

**实践项目：**
```java
// 项目3：本地模型聊天服务
@Configuration
public class OllamaConfiguration {
    
    @Bean
    public OllamaChatModel ollamaChatModel() {
        return OllamaChatModel.builder()
            .baseUrl("http://localhost:11434")
            .model("llama3.1:8b")
            .temperature(0.7)
            .build();
    }
}

@Service
public class LocalChatService {
    private final OllamaChatModel ollamaModel;
    private final OpenAiChatModel openAiModel;
    
    public String chat(String message, boolean useLocal) {
        ChatModel model = useLocal ? ollamaModel : openAiModel;
        return model.call(message);
    }
    
    // 成本对比分析
    public CostAnalysis analyzeCost(String message) {
        long startTime = System.currentTimeMillis();
        String localResult = ollamaModel.call(message);
        long localTime = System.currentTimeMillis() - startTime;
        
        startTime = System.currentTimeMillis();
        String cloudResult = openAiModel.call(message);
        long cloudTime = System.currentTimeMillis() - startTime;
        
        return new CostAnalysis(localTime, cloudTime, localResult, cloudResult);
    }
    
    public record CostAnalysis(long localTime, long cloudTime, 
                              String localResult, String cloudResult) {}
}
```

**学习成果：**
- [ ] 成功部署Ollama本地环境
- [ ] 掌握本地模型与云端模型的切换
- [ ] 理解成本控制策略
- [ ] 完成本地模型聊天服务

#### 第6周：提示词工程实践
**学习内容：**
- 高级提示词技巧
- 少样本学习（Few-shot Learning）
- 思维链（Chain of Thought）
- 提示词模板设计

**实践项目：**
```java
// 项目4：高级聊天机器人
@Service
public class AdvancedChatService {
    private final ChatClient chatClient;
    
    // 角色扮演聊天
    public String rolePlayChat(String message, String role) {
        return chatClient.prompt()
            .system("""
                你现在扮演{role}，请始终保持这个角色特征：
                - 说话风格要符合角色特点
                - 知识范围要符合角色背景
                - 回答要专业且有趣
                """, Map.of("role", role))
            .user(message)
            .call()
            .content();
    }
    
    // 思维链推理
    public String chainOfThought(String problem) {
        return chatClient.prompt()
            .system("""
                请使用思维链的方式解决问题：
                1. 首先分析问题
                2. 列出解决步骤
                3. 逐步推理
                4. 得出结论
                """)
            .user(problem)
            .call()
            .content();
    }
}
```

**测试代码：**
```java
// 测试类：验证提示词工程效果
@SpringBootTest
class AdvancedChatServiceTest {
    
    @Autowired
    private AdvancedChatService chatService;
    
    @Test
    void testRolePlayChat() {
        String response = chatService.rolePlayChat("如何学习Java？", "资深Java架构师");
        
        assertThat(response).isNotEmpty();
        assertThat(response.toLowerCase()).contains("java");
        // 验证回答是否符合架构师角色特征
        assertThat(response).containsAnyOf("架构", "设计模式", "最佳实践");
    }
    
    @Test
    void testChainOfThought() {
        String problem = "如何设计一个高并发的电商系统？";
        String response = chatService.chainOfThought(problem);
        
        assertThat(response).isNotEmpty();
        // 验证是否包含思维链的关键步骤
        assertThat(response).containsAnyOf("分析", "步骤", "推理", "结论");
    }
    
    @Test
    void testPromptTemplateConsistency() {
        // 测试提示词模板的一致性
        String role = "产品经理";
        String response1 = chatService.rolePlayChat("产品规划", role);
        String response2 = chatService.rolePlayChat("用户需求", role);
        
        // 验证角色一致性
        assertThat(response1).isNotEmpty();
        assertThat(response2).isNotEmpty();
    }
}
```

**学习成果：**
- [ ] 掌握高级提示词工程技巧
- [ ] 实现角色扮演和思维链功能
- [ ] 设计可复用的提示词模板
- [ ] 完成高级聊天机器人项目
- [ ] 编写完整的测试用例

### ✅ 第一阶段评估标准
- [ ] 能够解释LLM的基本原理和架构
- [ ] 熟练使用Spring AI基础API
- [ ] 掌握提示词工程技巧
- [ ] 完成4个实践项目（包含测试代码）
- [ ] 理解AI应用开发的基本流程
- [ ] 掌握本地模型与云端模型的选择策略
- [ ] 能够进行成本效益分析

### 🔍 **第2周技能检验**
**理论测试：**
- Transformer架构核心组件说明
- 注意力机制工作原理
- 预训练vs微调的区别

**实践测试：**
- 独立搭建Spring AI开发环境
- 实现基础聊天功能
- 编写单元测试

### 🔍 **第4周技能检验**
**理论测试：**
- 提示词工程最佳实践
- 本地模型vs云端模型对比
- AI应用架构设计原则

**实践测试：**
- 设计复杂提示词模板
- 实现多模型切换功能
- 完成性能对比分析

**🎯 第一阶段面试重点：**
- AI基础理论（Transformer、注意力机制、预训练vs微调）
- Spring AI框架核心概念和优势
- 企业级AI应用架构设计原则
- 提示词工程最佳实践和技巧

---

## 🔧 第二阶段：RAG技术深入 + 向量数据库实践（5-6周）

> **⏱️ 时间分配**：快速路径5周，深度路径6周
> **🎯 核心目标**：掌握企业级RAG系统设计和实现

### 🎯 学习目标
- 深入理解RAG技术原理和架构
- 掌握向量数据库的使用和优化
- 学会文档处理和分块技术
- 构建完整的RAG应用系统

### 📋 详细安排

#### 第7-9周：RAG技术原理
**学习内容：**
- RAG架构和工作流程
- 文档预处理和分块策略
- 向量化和嵌入技术
- 相似度搜索算法

**学习资源：**
- 📖 《Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks》
- 🎥 [LangChain RAG教程](https://www.youtube.com/watch?v=TLf90ipRKz8)
- 📝 [向量数据库对比分析](https://zilliz.com/comparison)
- 🔗 [PostgreSQL pgvector文档](https://github.com/pgvector/pgvector)

**实践项目：**
```java
// 项目4：基础RAG系统
@Service
public class BasicRAGService {
    private final VectorStore vectorStore;
    private final ChatClient chatClient;
    private final TextSplitter textSplitter;
    
    public void addDocument(String content, String title) {
        // 1. 文档分块
        List<Document> documents = textSplitter.apply(
            List.of(new Document(content, Map.of("title", title)))
        );
        
        // 2. 向量化存储
        vectorStore.add(documents);
    }
    
    public String query(String question) {
        // 1. 检索相关文档
        List<Document> relevantDocs = vectorStore.similaritySearch(question, 5);
        
        // 2. 构建上下文
        String context = relevantDocs.stream()
            .map(Document::getContent)
            .collect(Collectors.joining("\n\n"));
        
        // 3. 生成回答
        return chatClient.prompt()
            .system("""
                你是一个知识库助手。请基于以下上下文回答问题：
                {context}
                
                如果上下文中没有相关信息，请明确说明。
                """, Map.of("context", context))
            .user(question)
            .call()
            .content();
    }
}
```

**学习成果：**
- [ ] 理解RAG技术原理和架构
- [ ] 掌握文档分块策略
- [ ] 实现基础RAG系统
- [ ] 理解向量化技术

#### 第10-12周：向量数据库与多存储引擎实践
**学习内容：**
- PostgreSQL + pgvector配置
- Redis向量搜索（Redis Stack）
- Elasticsearch集成和配置
- 向量索引优化
- 相似度计算算法
- 混合检索策略
- 批量处理技术
- 多存储引擎选型策略

**学习资源：**
- 📖 [pgvector官方文档](https://github.com/pgvector/pgvector)
- 📖 [Redis Vector Search文档](https://redis.io/docs/interact/search-and-query/search/vectors/)
- 📖 [Elasticsearch官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
- 🎥 PostgreSQL向量搜索教程
- 🎥 Redis向量搜索实战教程
- 🎥 [Elasticsearch与Spring Boot集成教程](https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/index.html)
- 📝 [向量数据库性能优化指南](https://github.com/pgvector/pgvector/wiki)
- 📝 [混合检索最佳实践](https://www.elastic.co/blog/improving-information-retrieval-elastic-stack-hybrid)
- 📝 [Redis向量搜索性能对比](https://redis.com/blog/redisearch-vector-similarity/)

**实践项目：**
```java
// 项目5：多存储引擎RAG系统
@Configuration
public class VectorStoreConfiguration {
    
    // PostgreSQL + pgvector配置
    @Bean
    @Primary
    public VectorStore pgVectorStore(JdbcTemplate jdbcTemplate, EmbeddingModel embeddingModel) {
        return PgVectorStore.builder(jdbcTemplate, embeddingModel)
            .dimensions(1536)  // OpenAI embedding dimensions
            .distanceType(PgVectorStore.PgDistanceType.COSINE_DISTANCE)
            .indexType(PgVectorStore.PgIndexType.HNSW)
            .initializeSchema(true)
            .build();
    }
    
    // Redis向量搜索配置
    @Bean
    public RedisVectorStore redisVectorStore(RedisTemplate<String, Object> redisTemplate, 
                                           EmbeddingModel embeddingModel) {
        return RedisVectorStore.builder(redisTemplate, embeddingModel)
            .indexName("document_vectors")
            .prefix("doc:")
            .dimensions(1536)
            .distanceType(RedisVectorStore.DistanceType.COSINE)
            .algorithm(RedisVectorStore.Algorithm.HNSW)
            .build();
    }
    
    // Redis配置
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        LettuceConnectionFactory factory = new LettuceConnectionFactory(
            new RedisStandaloneConfiguration("localhost", 6379)
        );
        return factory;
    }
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}

// 向量数据库选型服务
@Service
public class VectorStoreSelectionService {
    private final VectorStore pgVectorStore;
    private final RedisVectorStore redisVectorStore;
    private final ElasticsearchService elasticsearchService;
    
    /**
     * 向量数据库选型策略（面试重点）
     * 
     * 1. Redis向量搜索：
     *    - 优势：极高性能、低延迟、内存存储、支持实时更新
     *    - 劣势：内存成本高、数据持久化依赖配置
     *    - 适用场景：实时推荐、在线搜索、小到中等规模数据集
     * 
     * 2. PostgreSQL + pgvector：
     *    - 优势：ACID事务、SQL查询、成本低、数据一致性
     *    - 劣势：性能不如专业向量数据库、扩展性有限
     *    - 适用场景：企业级应用、需要事务保证、预算有限
     * 
     * 3. Elasticsearch：
     *    - 优势：全文搜索 + 向量搜索、分布式、可扩展
     *    - 劣势：复杂度高、资源消耗大、学习成本高
     *    - 适用场景：大规模文档搜索、混合检索、企业搜索平台
     */
    
    public VectorStore selectOptimalStore(SearchContext context) {
        if (context.isRealTimeRequired() && context.getDataSize() < 1_000_000) {
            return redisVectorStore; // 实时场景选择Redis
        } else if (context.requiresTransactions()) {
            return pgVectorStore; // 需要事务选择PostgreSQL
        } else {
            return pgVectorStore; // 默认选择PostgreSQL
        }
    }
}

@Service
public class AdvancedRAGService {
    private final VectorStore pgVectorStore;
    private final RedisVectorStore redisVectorStore;
    private final ChatClient chatClient;
    
    // Redis高性能搜索
    public String fastSearch(String question) {
        List<Document> relevantDocs = redisVectorStore.similaritySearch(
            SearchRequest.builder()
                .query(question)
                .topK(3)
                .similarityThreshold(0.8)
                .build()
        );
        
        return generateAnswer(question, relevantDocs);
    }
    
    // 带过滤的搜索
    public String queryWithFilter(String question, Map<String, Object> filters) {
        // 构建过滤表达式
        FilterExpressionBuilder builder = new FilterExpressionBuilder();
        Expression filterExpression = builder.and(
            filters.entrySet().stream()
                .map(entry -> builder.eq(entry.getKey(), entry.getValue()))
                .toArray(Expression[]::new)
        ).build();
        
        // 检索文档
        List<Document> relevantDocs = pgVectorStore.similaritySearch(
            SearchRequest.builder()
                .query(question)
                .topK(5)
                .filterExpression(filterExpression)
                .build()
        );
        
        return generateAnswer(question, relevantDocs);
    }
    
    // 混合搜索（向量 + 全文）
    public String hybridSearch(String query) {
        // 向量搜索
        List<Document> vectorResults = pgVectorStore.similaritySearch(query, 3);
        
        // Elasticsearch全文搜索
        List<Document> textResults = elasticsearchService.search(query, 3);
        
        // 结果融合
        List<Document> combinedResults = mergeResults(vectorResults, textResults);
        
        return generateAnswer(query, combinedResults);
    }
}

// Elasticsearch集成服务
@Service
public class ElasticsearchService {
    private final ElasticsearchClient elasticsearchClient;
    
    public List<Document> search(String query, int size) {
        try {
            SearchRequest searchRequest = SearchRequest.of(s -> s
                .index("documents")
                .query(q -> q
                    .multiMatch(m -> m
                        .query(query)
                        .fields("title^2", "content")
                        .type(TextQueryType.BestFields)
                    )
                )
                .size(size)
                .highlight(h -> h
                    .fields("content", f -> f.fragmentSize(150))
                )
            );
            
            SearchResponse<DocumentEntity> response = elasticsearchClient.search(
                searchRequest, DocumentEntity.class
            );
            
            return response.hits().hits().stream()
                .map(hit -> new Document(
                    hit.source().getContent(),
                    Map.of(
                        "title", hit.source().getTitle(),
                        "score", hit.score(),
                        "highlight", hit.highlight()
                    )
                ))
                .collect(Collectors.toList());
                
        } catch (Exception e) {
            throw new SearchException("Elasticsearch搜索失败", e);
        }
    }
    
    public void indexDocument(String id, String title, String content) {
        try {
            DocumentEntity doc = new DocumentEntity(title, content);
            IndexRequest<DocumentEntity> request = IndexRequest.of(i -> i
                .index("documents")
                .id(id)
                .document(doc)
            );
            
            elasticsearchClient.index(request);
        } catch (Exception e) {
            throw new IndexException("文档索引失败", e);
        }
    }
}
}
```

**学习成果：**
- [ ] 熟练使用PostgreSQL + pgvector
- [ ] 掌握Redis向量搜索配置和使用
- [ ] 掌握Elasticsearch集成和配置
- [ ] 掌握向量索引优化技巧
- [ ] 实现高级RAG功能
- [ ] 理解混合搜索策略
- [ ] 掌握多存储引擎选型策略

### 🔍 **第8周技能检验**
**理论测试：**
- RAG架构组件和工作流程
- 向量化技术原理
- 文档分块策略选择

**实践测试：**
- 搭建基础RAG系统
- 实现文档向量化存储
- 完成相似度搜索功能

### 🔍 **第12周技能检验**
**理论测试：**
- 向量数据库vs传统数据库
- 混合检索策略设计
- 检索效果评估方法

**实践测试：**
- 配置PostgreSQL + pgvector
- 集成Elasticsearch搜索
- 实现混合检索功能
- 完成性能优化

#### 第13-14周：文档处理系统
**学习内容：**
- 多格式文档处理（PDF、Word、Excel等）
- OCR技术应用
- 文档预处理流水线
- 批量处理优化

**实践项目：**
```java
// 项目6：文档处理系统
@Service
public class DocumentProcessingService {
    private final DocumentReader pdfReader;
    private final DocumentReader tikaReader;
    private final VectorStore vectorStore;
    private final TextSplitter textSplitter;
    
    public void processDocument(MultipartFile file, String category) {
        try {
            // 1. 读取文档
            List<Document> documents = readDocument(file);
            
            // 2. 文档分块
            List<Document> chunks = textSplitter.apply(documents);
            
            // 3. 添加元数据
            chunks.forEach(chunk -> {
                chunk.getMetadata().put("source", file.getOriginalFilename());
                chunk.getMetadata().put("category", category);
                chunk.getMetadata().put("timestamp", Instant.now().toString());
            });
            
            // 4. 向量化存储
            vectorStore.add(chunks);
            
        } catch (Exception e) {
            throw new DocumentProcessingException("文档处理失败", e);
        }
    }
    
    private List<Document> readDocument(MultipartFile file) {
        String filename = file.getOriginalFilename();
        if (filename != null && filename.toLowerCase().endsWith(".pdf")) {
            return pdfReader.get();
        } else {
            return tikaReader.get();
        }
    }
}
```

**学习成果：**
- [ ] 掌握多格式文档处理
- [ ] 实现文档预处理流水线
- [ ] 优化批量处理性能
- [ ] 完成文档处理系统

### ✅ 第二阶段评估标准
- [ ] 深入理解RAG技术原理
- [ ] 熟练使用向量数据库
- [ ] 掌握文档处理技术
- [ ] 完成3个RAG相关项目
- [ ] 能够设计RAG应用架构

**🎯 第二阶段面试重点：**
- RAG技术原理和架构演进
- 向量数据库选型和性能优化
- 大规模文档处理策略
- 检索质量评估和优化方法

---

## 🔗 第三阶段：LangChain4j框架 + 多框架对比（4-5周）

> **⏱️ 时间分配**：快速路径4周，深度路径5周
> **🎯 核心目标**：掌握LangChain4j框架，进行技术栈对比选择，学习Agent开发基础
> **📝 说明**：与Spring AI形成互补，提升Java生态AI开发能力

### 🎯 学习目标
- 掌握LangChain4j核心概念和API
- 理解LangChain4j与Spring AI的差异和优势
- 学会多框架集成和选型策略
- 构建基于LangChain4j的AI应用
- 【面试重点】能够对比分析两个框架的适用场景

### 📅 详细安排

#### 第13-14周：LangChain4j基础和核心概念

**学习内容：**
- LangChain4j架构和设计理念
- 核心组件：ChatLanguageModel、EmbeddingModel、DocumentLoader
- 与Spring AI的对比分析
- Java生态AI开发最佳实践

**实践项目：**
```java
// 项目7：LangChain4j基础应用
@Service
public class LangChain4jChatService {

    private final ChatLanguageModel chatModel;
    private final EmbeddingModel embeddingModel;

    public LangChain4jChatService() {
        // LangChain4j模型配置
        this.chatModel = OpenAiChatModel.builder()
            .apiKey(System.getenv("OPENAI_API_KEY"))
            .modelName("gpt-4")
            .temperature(0.7)
            .build();

        this.embeddingModel = OpenAiEmbeddingModel.builder()
            .apiKey(System.getenv("OPENAI_API_KEY"))
            .modelName("text-embedding-3-small")
            .build();
    }

    public String chat(String message) {
        return chatModel.generate(message);
    }

    public List<Float> embed(String text) {
        Response<Embedding> response = embeddingModel.embed(text);
        return response.content().vector();
    }
}
```

**框架对比分析（面试重点）：**
```java
// Spring AI vs LangChain4j 对比
@Component
public class FrameworkComparison {
    /*
    面试标准答案：

    Spring AI优势：
    1. Spring生态集成：无缝集成Spring Boot、Spring Security等
    2. 自动配置：开箱即用的配置和依赖注入
    3. 企业级特性：内置监控、安全、扩展性支持
    4. 类型安全：强类型API设计

    LangChain4j优势：
    1. 功能丰富：更多的AI工具和集成选项
    2. 链式操作：支持复杂的AI工作流
    3. 灵活性：更灵活的配置和扩展
    4. 社区活跃：快速迭代和功能更新

    选型建议：
    - Spring AI：适合Spring生态、企业级应用、简单AI集成
    - LangChain4j：适合复杂AI工作流、多样化AI工具集成
    - 混合使用：在同一项目中根据场景选择合适的框架
    */
}
```

#### 第15-16周：LangChain4j高级特性和RAG实现

**学习内容：**
- LangChain4j的RAG实现方式
- 文档加载器和文本分割器
- 内存管理和对话历史
- 工具调用和Agent开发

**实践项目：**
```java
// 项目8：LangChain4j RAG系统
@Service
public class LangChain4jRAGService {

    private final EmbeddingStore<TextSegment> embeddingStore;
    private final EmbeddingModel embeddingModel;
    private final ChatLanguageModel chatModel;

    public LangChain4jRAGService() {
        // 初始化组件
        this.embeddingModel = OpenAiEmbeddingModel.builder()
            .apiKey(System.getenv("OPENAI_API_KEY"))
            .build();

        this.embeddingStore = InMemoryEmbeddingStore.builder()
            .build();

        this.chatModel = OpenAiChatModel.builder()
            .apiKey(System.getenv("OPENAI_API_KEY"))
            .build();
    }

    public void addDocument(String filePath) {
        // 文档加载和分割
        DocumentParser parser = new ApacheTikaDocumentParser();
        Document document = FileSystemDocumentLoader.loadDocument(filePath, parser);

        DocumentSplitter splitter = DocumentSplitters.recursive(300, 30);
        List<TextSegment> segments = splitter.split(document);

        // 向量化和存储
        List<Embedding> embeddings = embeddingModel.embedAll(segments).content();
        embeddingStore.addAll(embeddings, segments);
    }

    public String query(String question) {
        // 检索相关文档
        Embedding questionEmbedding = embeddingModel.embed(question).content();
        List<EmbeddingMatch<TextSegment>> relevant = embeddingStore.findRelevant(
            questionEmbedding, 5, 0.7);

        // 构建上下文
        String context = relevant.stream()
            .map(match -> match.embedded().text())
            .collect(Collectors.joining("\n"));

        // 生成回答
        String prompt = String.format(
            "基于以下上下文回答问题：\n%s\n\n问题：%s", context, question);

        return chatModel.generate(prompt);
    }
}
```

**多框架集成策略：**
```java
// 项目9：多框架集成服务
@Service
public class MultiFrameworkAIService {

    private final SpringAIService springAIService;
    private final LangChain4jService langChain4jService;

    public String processRequest(AIRequest request) {
        /*
        框架选择策略（面试重点）：

        1. 简单对话：Spring AI
           - 优势：配置简单，性能稳定
           - 适用：基础聊天、简单问答

        2. 复杂RAG：LangChain4j
           - 优势：文档处理能力强，RAG工具丰富
           - 适用：知识库问答、文档分析

        3. 企业集成：Spring AI
           - 优势：Spring生态集成，企业级特性
           - 适用：微服务架构、企业应用

        4. 工具调用：LangChain4j
           - 优势：工具集成丰富，Agent开发便利
           - 适用：复杂业务流程、多步骤任务
        */

        return switch (request.getType()) {
            case SIMPLE_CHAT -> springAIService.chat(request.getMessage());
            case COMPLEX_RAG -> langChain4jService.ragQuery(request.getMessage());
            case ENTERPRISE_INTEGRATION -> springAIService.enterpriseProcess(request);
            case TOOL_CALLING -> langChain4jService.agentProcess(request);
        };
    }
}
```

### 🔍 **第16周技能检验**
**理论测试：**
- LangChain4j核心组件和架构
- Spring AI vs LangChain4j对比分析
- 框架选型决策因素

**实践测试：**
- 使用LangChain4j构建RAG系统
- 实现多框架集成服务
- 编写框架对比测试用例

**测试代码示例：**
```java
@SpringBootTest
class MultiFrameworkIntegrationTest {
    
    @Autowired
    private MultiFrameworkAIService aiService;
    
    @Test
    void testFrameworkSelection() {
        // 测试简单对话场景
        AIRequest chatRequest = new AIRequest(AIRequestType.SIMPLE_CHAT, "Hello");
        String response = aiService.processRequest(chatRequest);
        assertThat(response).isNotEmpty();
        
        // 测试复杂RAG场景
        AIRequest ragRequest = new AIRequest(AIRequestType.COMPLEX_RAG, "查询文档内容");
        String ragResponse = aiService.processRequest(ragRequest);
        assertThat(ragResponse).isNotEmpty();
    }
    
    @Test
    void testPerformanceComparison() {
        String testQuery = "测试查询";
        
        // Spring AI性能测试
        long springStartTime = System.currentTimeMillis();
        String springResult = springAIService.chat(testQuery);
        long springDuration = System.currentTimeMillis() - springStartTime;
        
        // LangChain4j性能测试
        long langchainStartTime = System.currentTimeMillis();
        String langchainResult = langChain4jService.chat(testQuery);
        long langchainDuration = System.currentTimeMillis() - langchainStartTime;
        
        // 性能对比分析
        System.out.printf("Spring AI: %dms, LangChain4j: %dms%n", 
                         springDuration, langchainDuration);
    }
}
```

### ✅ 第三阶段评估标准
- [ ] 熟练使用LangChain4j核心API
- [ ] 理解两个框架的差异和优势
- [ ] 能够根据场景选择合适的框架
- [ ] 完成2个LangChain4j项目
- [ ] 实现多框架集成应用
- [ ] 编写完整的对比测试用例

**🎯 第三阶段面试重点：**
- LangChain4j核心概念和架构设计
- Spring AI vs LangChain4j详细对比分析
- 多框架集成策略和最佳实践
- Java生态AI开发技术选型

---

## ⚙️ 第四阶段：高级特性 + Agent开发（4-6周）

> **⏱️ 时间分配**：快速路径4周，深度路径6周
> **🎯 核心目标**：掌握Agent开发、MCP协议和高级AI应用特性
> **📝 说明**：MCP协议从可选变为必学内容

### 🎯 学习目标
- 掌握Agent开发核心技术
- 深入理解MCP协议原理和应用
- 学会Spring AI和LangChain4j高级特性
- 理解多模型集成策略
- 构建智能化AI应用
- 掌握工具调用和外部系统集成

### 📅 详细安排

#### 第17-18周：MCP协议深入
**学习内容：**
- MCP协议架构和原理
- 工具调用机制
- 上下文管理
- 多模型集成策略

**学习资源：**
- 📚 [MCP官方文档](https://modelcontextprotocol.io/)
- 🎥 MCP协议详解视频
- 📝 [Spring AI MCP集成指南](https://docs.spring.io/spring-ai/reference/api/tools.html)

**实践项目：**
```java
// 项目7：MCP工具集成系统
@Service
public class MCPService {
    
    @Tool(description = "获取实时天气信息")
    public WeatherInfo getWeather(
        @Parameter(description = "城市名称") String city,
        @Parameter(description = "温度单位", required = false) String unit
    ) {
        return weatherApiClient.getWeather(city, unit != null ? unit : "celsius");
    }
    
    @Tool(description = "查询数据库信息")
    public List<Map<String, Object>> queryDatabase(
        @Parameter(description = "SQL查询语句") String sql
    ) {
        return jdbcTemplate.queryForList(sql);
    }
    
    @Tool(description = "发送邮件通知")
    public EmailResult sendEmail(
        @Parameter(description = "收件人邮箱") String to,
        @Parameter(description = "邮件主题") String subject,
        @Parameter(description = "邮件内容") String content
    ) {
        return emailService.sendEmail(to, subject, content);
    }
    
    public record WeatherInfo(String city, double temperature, String condition) {}
    public record EmailResult(String messageId, String status) {}
}

@Configuration
public class MCPConfiguration {
    
    @Bean
    public ToolCallbackProvider mcpTools(MCPService mcpService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(mcpService)
            .build();
    }
}
```

**学习成果：**
- [ ] 理解MCP协议原理
- [ ] 掌握工具调用机制
- [ ] 实现MCP工具集成
- [ ] 完成MCP应用系统

#### 第19-20周：Spring AI高级特性
**学习内容：**
- Advisors API使用
- 流式处理
- 批量操作
- 自定义扩展

**实践项目：**
```java
// 项目8：高级AI服务
@Component
public class LoggingAdvisor implements CallAdvisor {
    
    @Override
    public ChatClientResponse adviseCall(ChatClientRequest request, CallAdvisorChain chain) {
        long startTime = System.currentTimeMillis();
        
        ChatClientResponse response = chain.nextCall(request);
        
        long duration = System.currentTimeMillis() - startTime;
        logger.info("AI请求耗时: {}ms, 输入长度: {}, 输出长度: {}", 
            duration, 
            request.getPrompt().getInstructions().length(),
            response.getResult().getOutput().getContent().length()
        );
        
        return response;
    }
}

@Service
public class AdvancedAIService {
    private final ChatClient chatClient;
    
    // 流式处理
    public Flux<String> streamChat(String message) {
        return chatClient.prompt(message)
            .stream()
            .content();
    }
    
    // 批量处理
    public List<String> batchProcess(List<String> messages) {
        return messages.parallelStream()
            .map(message -> chatClient.prompt(message).call().content())
            .collect(Collectors.toList());
    }
    
    // 多模型集成
    public String multiModelChat(String message, String modelType) {
        ChatClient client = switch (modelType) {
            case "openai" -> openAiChatClient;
            case "anthropic" -> anthropicChatClient;
            case "ollama" -> ollamaChatClient;
            default -> chatClient;
        };
        
        return client.prompt(message).call().content();
    }
}
```

**学习成果：**
- [ ] 掌握Spring AI高级特性
- [ ] 实现自定义Advisor
- [ ] 支持流式和批量处理
- [ ] 完成多模型集成

#### 第21-22周：复杂AI应用
**学习内容：**
- 复杂业务逻辑集成
- 错误处理和重试机制
- 性能优化技巧
- 安全机制实现

**实践项目：**
```java
// 项目9：智能工作流系统
@Service
public class IntelligentWorkflowService {
    private final ChatClient chatClient;
    private final List<ToolCallback> toolCallbacks;
    
    public WorkflowResult processWorkflow(WorkflowRequest request) {
        return chatClient.prompt()
            .system("""
                你是一个智能工作流处理器，可以：
                1. 分析工作流需求
                2. 调用相应的工具
                3. 协调多个步骤
                4. 处理异常情况
                """)
            .user("""
                工作流请求：
                - 类型：{type}
                - 参数：{parameters}
                - 优先级：{priority}
                """, Map.of(
                "type", request.getType(),
                "parameters", request.getParameters(),
                "priority", request.getPriority()
            ))
            .toolCallbacks(toolCallbacks)
            .call()
            .entity(WorkflowResult.class);
    }
    
    public record WorkflowRequest(String type, Map<String, Object> parameters, String priority) {}
    public record WorkflowResult(String status, String result, List<String> steps) {}
}
```

**学习成果：**
- [ ] 实现复杂AI应用逻辑
- [ ] 掌握错误处理机制
- [ ] 完成智能工作流系统

### 🔍 **第18周技能检验**
**理论测试：**
- MCP协议架构和工作原理
- 工具调用机制设计
- 上下文管理策略

**实践测试：**
- 实现MCP工具集成
- 开发自定义工具函数
- 完成多工具协作场景

### 🔍 **第22周技能检验**
**理论测试：**
- Spring AI高级特性应用
- 多模型集成策略
- 性能优化技巧

**实践测试：**
- 构建智能工作流系统
- 实现流式和批量处理
- 完成错误处理和重试机制

### ✅ 第四阶段评估标准
- [ ] 深入理解MCP协议（可选）
- [ ] 掌握Agent开发技术
- [ ] 实现多模型集成
- [ ] 完成3个高级项目
- [ ] 能够设计复杂AI应用

**🎯 第四阶段面试重点：**
- Agent开发模式和架构设计
- 工具调用和集成策略
- 高级AI应用特性和优化
- 复杂业务场景的AI解决方案

---

## 🏢 第五阶段：企业级应用实战（8-10周）

> **⏱️ 时间分配**：快速路径8周，深度路径10周
> **🎯 核心目标**：构建完整的企业级AI应用系统，掌握生产环境部署
> **📝 说明**：前三阶段为理论学习+小项目实践，本阶段为完整企业应用实战

### 🎯 学习目标
- 构建完整的商业级AI应用
- 掌握企业级架构设计
- 学会团队协作开发
- 掌握Docker容器化部署
- 理解Kubernetes生产环境部署
- 掌握监控和日志管理
- 具备企业面试竞争力
- 掌握前沿AI技术栈

### 📅 详细安排

#### 第23-24周：企业级AI基础架构设计

**学习内容：**
- 企业级AI服务架构设计
- 多租户系统设计
- 安全认证和权限控制
- 性能监控和告警

**核心架构实现：**
```java
// 企业级AI服务架构
@Configuration
public class EnterpriseAIConfiguration {

    // 连接池管理
    @Bean
    public ChatClient chatClient(ChatClient.Builder builder) {
        return builder
            .defaultSystem("企业级AI助手")
            .defaultOptions(ChatOptions.builder()
                .temperature(0.7)
                .maxTokens(2000)
                .timeout(Duration.ofSeconds(30))
                .build())
            .build();
    }

    // 缓存策略
    @Bean
    public CacheManager aiCacheManager() {
        return RedisCacheManager.builder()
            .cacheDefaults(CacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1)))
            .build();
    }

    // 限流控制
    @Bean
    public RateLimiter aiRateLimiter() {
        return RateLimiter.create(100.0); // 每秒100个请求
    }
}
```

**面试重点：技术选型对比**
```java
// 向量数据库选型决策（面试必问）
@Component
public class VectorStoreComparison {
    /*
    面试标准答案：

    1. PostgreSQL + pgvector：
       - 优势：与现有数据库集成、ACID支持、运维成熟
       - 劣势：性能不如专业向量数据库
       - 适用：中小规模、已有PostgreSQL基础设施

    2. Elasticsearch：
       - 优势：全文检索 + 向量检索、生态成熟
       - 劣势：内存消耗大、配置复杂
       - 适用：需要混合检索的场景

    3. Redis：
       - 优势：高性能、低延迟、简单部署
       - 劣势：内存限制、持久化考虑
       - 适用：实时推荐、缓存场景
    */
}
```

#### 第25-26周：智能客服系统
**项目概述：**
- 多轮对话管理
- 知识库集成
- 情感分析
- 人工转接
- 多租户支持
- 企业级安全控制

**技术栈：**
- Spring AI + RAG
- PostgreSQL + pgvector
- Redis缓存
- WebSocket实时通信
- Spring Security
- Kubernetes部署

**核心功能实现：**
```java
// 项目10：企业级智能客服系统
@RestController
@RequestMapping("/api/customer-service")
public class EnterpriseCustomerServiceController {

    private final CustomerServiceBot serviceBot;
    private final SecurityService securityService;
    private final RateLimiter rateLimiter;
    private final AuditService auditService;

    @PostMapping("/chat")
    public ResponseEntity<ChatResponse> handleChat(
            @RequestBody ChatRequest request,
            @RequestHeader("Authorization") String token,
            @RequestHeader("X-Tenant-ID") String tenantId) {

        // 1. 认证授权
        User user = securityService.validateToken(token);
        Tenant tenant = tenantService.validateTenant(tenantId);

        // 2. 限流控制
        if (!rateLimiter.tryAcquire()) {
            return ResponseEntity.status(429).build();
        }

        // 3. 审计日志
        auditService.logChatRequest(user.getId(), request.getMessage(), tenantId);

        // 4. 处理对话
        ChatResponse response = serviceBot.handleMessage(
            request.getSessionId(),
            request.getMessage(),
            user.getId(),
            tenant
        );

        return ResponseEntity.ok(response);
    }
}

@Service
public class CustomerServiceBot {
    private final ChatClient chatClient;
    private final ConversationMemory conversationMemory;
    private final KnowledgeBaseService knowledgeBase;
    private final SentimentAnalyzer sentimentAnalyzer;
    private final EscalationService escalationService;

    public ChatResponse handleMessage(String sessionId, String message, String userId, Tenant tenant) {
        // 1. 情感分析
        SentimentAnalysis sentiment = sentimentAnalyzer.analyze(message);

        // 2. 获取对话历史（租户隔离）
        List<Message> history = conversationMemory.get(sessionId, 10, tenant.getId());

        // 3. 知识库检索（租户权限控制）
        List<Document> relevantDocs = knowledgeBase.search(message, tenant);

        // 4. 生成回答
        String response = chatClient.prompt()
            .system(buildSystemPrompt(sentiment, tenant))
            .messages(history)
            .user(message)
            .call()
            .content();

        // 5. 记录对话
        conversationMemory.add(sessionId, message, response, tenant.getId());

        // 6. 检查是否需要人工转接
        if (shouldEscalateToHuman(sentiment, history, tenant.getEscalationRules())) {
            return escalationService.escalateToHuman(sessionId, message, userId, tenant);
        }

        return new ChatResponse(response, sentiment.getLevel());
    }
    
    private String buildSystemPrompt(SentimentAnalysis sentiment) {
        return """
            你是一个专业的客服助手。请：
            1. 保持友好和专业的态度
            2. 基于知识库提供准确信息
            3. 根据用户情绪调整回复风格
            4. 适时提供解决方案
            """;
    }
}
```

**学习成果：**
- [ ] 实现多轮对话管理
- [ ] 集成知识库和情感分析
- [ ] 支持人工转接机制
- [ ] 完成智能客服系统

#### 第27-28周：企业知识管理平台
**项目概述：**
- 多格式文档处理
- 智能分类和标签
- 混合检索（向量+全文）
- 企业级权限管理
- 多租户数据隔离

**技术栈：**
- Spring AI + RAG
- Elasticsearch + PostgreSQL
- MinIO对象存储
- Spring Security
- Apache Tika文档解析

**面试重点：RAG架构演进**
```java
// RAG技术演进路径（面试必答）
@Service
public class EnterpriseRAGService {

    private final VectorStore vectorStore;
    private final ElasticsearchService elasticsearchService;
    private final RerankerService rerankerService;

    // 1. 基础RAG：简单检索 + 生成
    public String basicRAG(String question) {
        List<Document> docs = vectorStore.similaritySearch(question, 5);
        String context = docs.stream()
            .map(Document::getContent)
            .collect(Collectors.joining("\n"));
        return chatClient.prompt()
            .system("基于上下文回答：" + context)
            .user(question)
            .call().content();
    }

    // 2. 高级RAG：重排序 + 上下文优化
    public String advancedRAG(String question) {
        // 多路召回
        List<Document> vectorResults = vectorStore.similaritySearch(question, 10);
        List<Document> keywordResults = elasticsearchService.search(question, 10);

        // 结果融合
        List<Document> candidates = mergeResults(vectorResults, keywordResults);

        // 重排序
        List<Document> reranked = rerankerService.rerank(question, candidates, 5);

        return generateAnswer(question, reranked);
    }

    // 3. GraphRAG：知识图谱增强
    public String graphRAG(String question) {
        // 实体识别 + 图谱查询 + 向量检索
        List<String> entities = nerService.extractEntities(question);
        GraphResult graphResult = knowledgeGraph.query(entities);
        List<Document> vectorResults = vectorStore.similaritySearch(question, 5);

        return generateGraphAnswer(question, graphResult, vectorResults);
    }
}
```

**核心功能实现：**
```java
// 项目11：企业知识管理平台
@Service
public class KnowledgeManagementService {
    private final DocumentProcessor documentProcessor;
    private final VectorStore vectorStore;
    private final ElasticsearchService elasticsearchService;
    private final ChatClient chatClient;
    
    public void ingestDocument(MultipartFile file, String category, String userId) {
        // 1. 文档解析
        Document doc = documentProcessor.parse(file);
        
        // 2. 智能分类
        String autoCategory = classifyDocument(doc.getContent());
        
        // 3. 生成标签
        List<String> tags = generateTags(doc.getContent());
        
        // 4. 向量化存储
        doc.getMetadata().put("category", autoCategory);
        doc.getMetadata().put("tags", tags);
        doc.getMetadata().put("userId", userId);
        vectorStore.add(List.of(doc));
        
        // 5. 全文索引
        elasticsearchService.index(doc);
    }
    
    public SearchResult search(String query, SearchFilters filters, String userId) {
        // 1. 权限过滤
        filters.addUserFilter(userId);
        
        // 2. 向量搜索
        List<Document> vectorResults = vectorStore.similaritySearch(
            SearchRequest.builder()
                .query(query)
                .topK(10)
                .filterExpression(buildFilterExpression(filters))
                .build()
        );
        
        // 3. 全文搜索
        List<Document> textResults = elasticsearchService.search(query, filters);
        
        // 4. 结果融合和排序
        return mergeAndRankResults(vectorResults, textResults);
    }
    
    private String classifyDocument(String content) {
        return chatClient.prompt()
            .system("请将文档分类为：技术文档、产品手册、政策文件、培训材料、其他")
            .user(content.substring(0, Math.min(content.length(), 1000)))
            .call()
            .content();
    }
}
```

**学习成果：**
- [ ] 实现多格式文档处理
- [ ] 集成智能分类和标签
- [ ] 支持混合搜索
- [ ] 完成知识管理平台

#### 第29-30周：企业级Agent系统开发

**学习内容：**
- Agent架构设计和实现
- 工具调用和集成
- Multi-Agent协作
- 企业级安全控制

**核心Agent实现：**
```java
// 企业级Agent框架
@Component
public class EnterpriseAgent {

    private final DatabaseService databaseService;
    private final EmailService emailService;
    private final SecurityService securityService;

    @Tool(description = "查询企业数据库")
    public DatabaseResult queryDatabase(
        @Parameter(description = "SQL查询语句") String sql,
        @Parameter(description = "数据源名称") String datasource
    ) {
        // 安全检查：SQL注入防护、权限验证
        if (!sqlValidator.isValid(sql)) {
            throw new SecurityException("Invalid SQL detected");
        }

        if (!securityService.hasDataAccess(getCurrentUser(), datasource)) {
            throw new AccessDeniedException("No access to datasource: " + datasource);
        }

        return databaseService.query(sql, datasource);
    }

    @Tool(description = "发送企业通知")
    public NotificationResult sendNotification(
        @Parameter(description = "接收者") String recipient,
        @Parameter(description = "消息内容") String message,
        @Parameter(description = "通知类型") NotificationType type
    ) {
        // 企业级考虑：审批流程、发送频率限制
        if (type == NotificationType.URGENT) {
            approvalService.requireApproval(getCurrentUser(), recipient, message);
        }

        return notificationService.send(recipient, message, type);
    }

    // Agent执行引擎
    public AgentResult executeTask(BusinessTask task) {
        /*
        Agent执行模式（面试要点）：

        1. ReAct模式：
           - Reasoning：分析任务，制定计划
           - Acting：执行具体操作
           - Observing：观察结果，调整策略

        2. Planning模式：
           - 任务分解：复杂任务拆分为子任务
           - 依赖分析：确定任务执行顺序
           - 资源调度：合理分配计算资源
        */

        return agentExecutor.execute(task, ExecutionMode.REACT);
    }
}
```

#### 第31-32周：Docker容器化部署
**学习内容：**
- Docker容器化最佳实践
- 多阶段构建优化
- 容器安全配置
- Docker Compose编排

**实践项目：**
```dockerfile
# Dockerfile优化示例
FROM openjdk:17-jdk-slim as builder
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN ./mvnw clean package -DskipTests

FROM openjdk:17-jre-slim
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  ai-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - postgres
      - redis
  
  postgres:
    image: pgvector/pgvector:pg16
    environment:
      POSTGRES_DB: aiapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

#### 第33-34周：Kubernetes生产部署
**学习内容：**
- Kubernetes基础概念
- 部署策略和配置
- 服务发现和负载均衡
- 监控和日志管理

**实践项目：**
```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ai-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ai-app
  template:
    metadata:
      labels:
        app: ai-app
    spec:
      containers:
      - name: ai-app
        image: ai-app:latest
        ports:
        - containerPort: 8080
        env:
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: ai-secrets
              key: openai-api-key
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: ai-app-service
spec:
  selector:
    app: ai-app
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```

#### 第35-36周：性能测试和优化
**学习内容：**
- 性能测试和优化
- 安全加固
- 监控和告警
- 自动化部署

**实践项目：**
```java
// 项目12：生产级部署配置
@Configuration
public class ProductionConfiguration {
    
    @Bean
    public TaskExecutor aiTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());
        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 2);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("AI-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("ai-responses", "embeddings", "documents");
    }
}

@Service
public class ProductionAIService {
    
    @Async("aiTaskExecutor")
    public CompletableFuture<String> processAsync(String input) {
        return CompletableFuture.supplyAsync(() ->
            chatClient.prompt(input).call().content()
        );
    }
    
    @Cacheable("ai-responses")
    public String cachedResponse(String prompt) {
        return chatClient.prompt(prompt).call().content();
    }
    
    @CircuitBreaker(name = "ai-service", fallbackMethod = "fallbackResponse")
    public String resilientProcessing(String input) {
        return chatClient.prompt(input).call().content();
    }
    
    public String fallbackResponse(String input, Exception e) {
        return "AI服务暂时不可用，请稍后重试。";
    }
}
```

**学习成果：**
- [ ] 完成性能优化
- [ ] 实现安全加固
- [ ] 配置监控告警
- [ ] 成功部署到生产环境

### ✅ 第五阶段评估标准
- [ ] 完成智能客服系统
- [ ] 完成企业知识管理平台
- [ ] 通过性能和安全测试
- [ ] 成功部署到生产环境
- [ ] 掌握企业级开发流程

**🎯 第五阶段面试重点：**
- 企业级系统架构设计和实现
- 生产环境部署和运维经验
- 性能优化和安全加固实践
- 项目管理和团队协作能力

---

## 🚀 第六阶段：前沿技术探索（6-8周）

> **⏱️ 时间分配**：快速路径6周，深度路径8周
> **🎯 核心目标**：掌握大规模AI应用架构和前沿技术
> **📝 说明**：可选阶段，适合希望深入掌握前沿技术的学习者

### 🎯 学习目标
- 掌握大规模AI应用架构
- 学习高级优化技术
- 理解AI应用发展趋势
- 【面试重点】具备技术前瞻性和创新能力
- 建立技术影响力

### 📋 详细安排

#### 第37-38周：大规模应用架构
**学习内容：**
- 分布式AI系统
- 负载均衡策略
- 数据一致性
- 故障恢复机制

**实践项目：**
```java
// 项目13：分布式AI平台
@Service
public class DistributedAIService {
    
    @LoadBalanced
    public String processWithLoadBalancing(String input) {
        return loadBalancer.route(input);
    }
    
    @CircuitBreaker(name = "ai-service")
    public String resilientProcessing(String input) {
        return chatClient.prompt(input).call().content();
    }
    
    @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public String retryableProcessing(String input) {
        return chatClient.prompt(input).call().content();
    }
}
```

#### 第39-42周：前沿技术探索
**学习内容：**
- 多模态AI应用
- 边缘计算AI
- AI Agent开发
- 生成式AI新趋势

**实践项目：**
```java
// 项目14：多模态AI应用
@Service
public class MultimodalAIService {
    
    public String analyzeImageAndText(String imageUrl, String question) {
        // 图像分析
        ImageAnalysis imageAnalysis = imageAnalyzer.analyze(imageUrl);
        
        // 文本分析
        String analysis = chatClient.prompt()
            .system("基于图像分析结果回答问题")
            .user("""
                图像分析：{imageAnalysis}
                问题：{question}
                """, Map.of("imageAnalysis", imageAnalysis, "question", question))
            .call()
            .content();
            
        return analysis;
    }
}
```

### ✅ 第六阶段评估标准
- [ ] 掌握大规模应用架构
- [ ] 了解前沿技术趋势
- [ ] 完成创新项目原型
- [ ] 建立技术影响力

**🎯 第六阶段面试重点：**
- 大规模AI系统架构设计
- 前沿技术趋势和发展方向
- 技术创新和解决方案设计
- 技术领导力和团队影响力

---

## 📚 学习资源汇总

### 🎓 官方文档
- [Spring AI官方文档](https://docs.spring.io/spring-ai/reference/)
- [OpenAI API文档](https://platform.openai.com/docs)
- [PostgreSQL pgvector文档](https://github.com/pgvector/pgvector)
- [MCP协议文档](https://modelcontextprotocol.io/)

### 📖 推荐书籍
- 《Attention Is All You Need》
- 《Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks》
- 《Spring Boot实战》
- 《微服务架构设计模式》

### 🎥 在线课程
- [OpenAI官方教程](https://platform.openai.com/docs/quickstart)
- [Spring官方视频教程](https://spring.io/guides)
- [LangChain RAG教程](https://www.youtube.com/watch?v=TLf90ipRKz8)
- [向量数据库实战课程](https://www.youtube.com/watch?v=TLf90ipRKz8)

### 🔗 开源项目
- [Spring AI示例项目](https://github.com/spring-projects/spring-ai)
- [RAG应用模板](https://github.com/langchain-ai/langchain)
- [向量数据库对比](https://github.com/milvus-io/milvus)

---

## 🛠️ 开发环境配置

### 💻 必需工具
```bash
# 开发环境
- Java 17+
- Maven 3.8+
- IntelliJ IDEA 2023.1+
- Git 2.30+
- Docker 20.10+

# 数据库
- PostgreSQL 17+
- Redis 7.0+

# 监控工具
- Prometheus
- Grafana
- ELK Stack
```

### 🚀 环境搭建脚本
```bash
#!/bin/bash
# 开发环境一键搭建

# 1. 启动PostgreSQL + pgvector
docker run -d \
  --name postgres-vector \
  -p 5432:5432 \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=postgres \
  pgvector/pgvector:pg17

# 2. 启动Redis
docker run -d \
  --name redis \
  -p 6379:6379 \
  redis:7-alpine

# 3. 初始化数据库
docker exec -it postgres-vector psql -U postgres -c "CREATE EXTENSION IF NOT EXISTS vector;"
```

---

## 📊 学习进度跟踪

### 📊 进度评估表
**快速路径（30周）：**
| 阶段 | 时长 | 完整项目 | 技能掌握 | 完成标准 |
|------|------|----------|----------|----------|
| AI基础+Spring AI | 4周 | 3个 | LLM理论+Spring AI | 能开发基础AI应用 |
| RAG技术深入 | 7周 | 4个 | RAG系统设计 | 能构建企业知识库 |
| LangChain4j+多框架 | 4周 | 3个 | LangChain4j+框架对比 | 能选择合适框架 |
| 高级特性+Agent | 4周 | 3个 | Agent开发+MCP协议 | 能开发智能助手 |
| 企业实战 | 8周 | 3个 | 企业级架构+部署 | 能设计生产系统 |
| 前沿技术探索 | 6周 | 2个 | 前沿技术+创新 | 具备专家级能力 |

**深度路径（36周）：**
| 阶段 | 时长 | 完整项目 | 技能掌握 | 完成标准 |
|------|------|----------|----------|----------|
| AI基础+Spring AI | 5周 | 4个 | 深度理论+框架精通 | 能讲解AI原理 |
| RAG技术深入 | 9周 | 5个 | 高级RAG+优化 | 能优化大规模系统 |
| LangChain4j+多框架 | 5周 | 4个 | LangChain4j精通+集成 | 能设计多框架架构 |
| 高级特性+Agent | 6周 | 4个 | MCP+Agent+微调 | 能开发复杂AI应用 |
| 企业实战 | 10周 | 4个 | 企业级架构+K8s部署 | 能设计生产系统 |
| 前沿技术探索 | 8周 | 3个 | 前沿技术+创新 | 具备专家级能力 |

### ✅ 技能评估清单
- [ ] LLM基础理论理解
- [ ] Spring AI框架熟练使用
- [ ] RAG技术掌握
- [ ] MCP协议应用
- [ ] 向量数据库操作
- [ ] 企业级架构设计
- [ ] 性能优化技巧
- [ ] 生产环境部署
- [ ] 安全机制实现
- [ ] 监控和运维

---

## 💡 学习建议和注意事项

### 🎯 学习建议
1. **理论与实践结合**：每个概念都要有对应的实践项目
2. **循序渐进**：不要急于求成，打好基础很重要
3. **项目驱动**：通过实际项目来巩固学习成果
4. **社区参与**：积极参与开源社区和技术讨论
5. **持续更新**：关注技术发展趋势，及时更新知识

### ⚠️ 注意事项
1. **API成本控制**：合理使用AI API，控制开发成本
2. **数据安全**：注意敏感数据的处理和存储
3. **性能考虑**：AI应用通常比较耗资源，注意优化
4. **法律合规**：了解AI应用相关的法律法规
5. **伦理考虑**：注意AI应用的伦理问题

### 🔄 学习调整机制
- **每周回顾**：总结学习进度和问题
- **月度评估**：评估学习效果和调整计划
- **季度规划**：根据学习情况调整后续计划
- **持续改进**：根据技术发展更新学习内容

---

## 🎯 学习成果预期

### 🚀 技能提升
- 从AI小白到企业级AI应用开发专家
- 掌握完整的AI应用开发技术栈
- 具备独立设计和开发AI应用的能力
- 能够解决复杂的AI应用技术问题

### 💼 职业发展
- 成为AI应用开发领域的专业人才
- 具备企业级AI项目管理和技术领导能力
- 建立个人技术品牌和影响力
- 为职业发展打开新的方向

### 📁 项目成果
- 完成14个完整的AI应用项目
- 建立个人技术博客和开源项目
- 参与开源社区贡献
- 获得相关技术认证

---

## 📋 **企业面试准备清单**

### **🎯 技术深度问题**

**1. RAG技术架构**
```
Q: 如何设计一个支持千万级文档的RAG系统？
A:
- 分层存储：热数据Redis，温数据ES，冷数据对象存储
- 分布式检索：多节点并行检索，结果聚合
- 缓存策略：查询缓存、嵌入缓存、结果缓存
- 性能优化：异步处理、批量操作、连接池管理
```

**2. 模型选型与优化**
```
Q: 企业级应用如何选择和优化大模型？
A:
- 成本考虑：API费用 vs 自部署成本
- 性能要求：延迟、吞吐量、准确性平衡
- 安全合规：数据隐私、模型安全、审计要求
- 技术栈：与现有架构的集成难度
```

**3. 系统架构设计**
```
Q: 设计一个企业级AI应用的微服务架构
A:
- 网关层：API网关、认证授权、限流熔断
- 服务层：AI服务、业务服务、数据服务
- 数据层：关系数据库、向量数据库、缓存
- 基础设施：容器化、服务发现、配置中心
```

### **💼 项目经验展示**

**项目1：智能客服系统**
- **技术栈**：Spring AI + PostgreSQL + Redis + WebSocket
- **核心功能**：多轮对话、知识库检索、情感分析、人工转接
- **技术亮点**：实时流式响应、对话上下文管理、智能路由
- **性能指标**：响应时间<2s，并发支持1000+用户

**项目2：企业知识管理平台**
- **技术栈**：Spring AI + Elasticsearch + MinIO + Spring Security
- **核心功能**：文档解析、智能分类、语义搜索、权限控制
- **技术亮点**：多格式支持、混合检索、增量更新
- **业务价值**：检索效率提升60%，知识利用率提升40%

### **🔧 技术栈掌握程度**

| 技术领域 | 掌握程度 | 面试重点 |
|----------|----------|----------|
| **Spring AI** | 精通 | 架构设计、最佳实践 |
| **RAG技术** | 精通 | 性能优化、架构演进 |
| **向量数据库** | 熟练 | 选型决策、性能调优 |
| **模型微调** | 了解 | 技术原理、应用场景 |
| **Agent开发** | 熟练 | 架构设计、工具集成 |
| **生产部署** | 精通 | 容器化、监控、优化 |

---

## 🎯 **学习效率优化建议**

### **📈 针对Java高级工程师的学习优化**

**1. 利用已有技术基础**
- ✅ **跳过基础Java/Spring内容**：直接从AI概念开始
- ✅ **复用架构设计经验**：将AI服务视为微服务组件
- ✅ **应用企业级开发经验**：安全、监控、部署等

**2. 并行学习策略**
```
Week 1-2: AI理论基础 + Spring AI入门
Week 3-4: RAG技术 + 向量数据库（并行学习）
Week 5-6: 企业级特性 + Agent开发（并行学习）
```

**3. 项目驱动学习**
- 每周至少完成一个可运行的项目
- 项目复杂度递增，但都基于企业实际需求
- 每个项目都要考虑生产环境部署

**4. 面试准备策略**
- 从第4周开始，每周整理面试要点
- 建立技术问题库和标准答案
- 准备项目展示和技术方案讲解

**5. 学习动机维持**
- 设置每2周的里程碑检查
- 加入AI开发者社区，分享学习心得
- 关注行业动态，了解技术发展趋势

---

## 📚 **学习成果总结**

### **技术能力提升**
- ✅ 掌握企业级AI应用开发全栈技术
- ✅ 精通Spring AI和LangChain4j双框架开发
- ✅ 具备大规模RAG系统设计能力
- ✅ 熟练使用多种AI开发框架和工具
- ✅ 掌握Agent开发和高级AI应用特性
- ✅ 掌握生产环境部署和优化

### **项目经验积累**
- ✅ 完成10-15个完整的企业级AI项目
- ✅ 具备可展示的技术方案和代码
- ✅ 积累真实的性能优化经验
- ✅ 建立完整的技术知识体系
- ✅ 掌握多框架集成和技术选型

### **面试竞争力**
- ✅ 能够深入讨论AI技术原理和发展趋势
- ✅ 具备企业级架构设计能力
- ✅ 拥有丰富的项目实战经验
- ✅ 掌握Spring AI vs LangChain4j技术对比
- ✅ 具备多框架集成和技术选型能力
- ✅ 掌握前沿技术发展趋势

---

这个学习计划专门为Java高级工程师设计，充分利用已有的技术基础，快速建立AI应用开发能力，确保在企业面试中具备强大的竞争力。从基础理论到实战应用，每个阶段都有明确的学习目标和可衡量的成果。建议您根据自己的实际情况调整学习进度，保持持续学习的动力。祝您学习顺利！🎉